<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ondas Estacionarias en una Cuerda</title>
    <!-- Tailwind CSS para estilos rápidos y responsivos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fuente Inter para un look moderno -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Slate 900 */
            color: #e2e8f0; /* Slate 200 */
        }
        canvas {
            touch-action: none; /* Prevenir scroll en móviles al tocar el canvas */
        }
        /* Estilos personalizados para los sliders (range inputs) */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #38bdf8; /* Sky 400 */
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }
        /* Estilo especial para el slider de análisis (amarillo) */
        input[type=range].analysis-slider::-webkit-slider-thumb {
            background: #facc15; /* Yellow 400 */
            box-shadow: 0 0 10px rgba(250, 204, 21, 0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155; /* Slate 700 */
            border-radius: 2px;
        }
        .info-card {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Contenedor Principal -->
    <main class="w-full max-w-4xl space-y-6">
        
        <!-- Encabezado -->
        <header class="text-center space-y-2">
            <h1 class="text-3xl md:text-4xl font-bold text-sky-400">Ondas Estacionarias</h1>
            <p class="text-slate-400 text-sm md:text-base">Simulación de una cuerda con ambos extremos fijos</p>
        </header>

        <!-- --- NUEVO: Canvas de Componentes (Oculto por defecto) --- -->
        <div id="componentsContainer" class="hidden transition-all duration-500 ease-in-out">
            <div class="flex justify-between items-end px-2 mb-1">
                 <h3 class="text-xs font-semibold text-slate-400 uppercase tracking-wider">Desglose: Ondas Viajeras</h3>
                 <div class="flex gap-4 text-xs">
                    <div class="flex items-center gap-2 text-emerald-400">
                        <span class="w-2 h-2 rounded-full bg-emerald-400 block"></span> Derecha (&rarr;)
                    </div>
                    <div class="flex items-center gap-2 text-orange-400">
                        <span class="w-2 h-2 rounded-full bg-orange-400 block"></span> Izquierda (&larr;)
                    </div>
                 </div>
            </div>
            <div class="relative w-full aspect-[16/6] md:aspect-[3/1] bg-slate-800/50 rounded-xl shadow-lg border border-slate-700 overflow-hidden">
                <canvas id="componentsCanvas" class="w-full h-full block"></canvas>
            </div>
            <!-- Flecha conectora visual -->
            <div class="flex justify-center -my-2 relative z-10">
                <div class="bg-slate-700 text-slate-300 rounded-full p-1 border border-slate-600 shadow-md">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 13l-7 7-7-7m14-8l-7 7-7-7" />
                    </svg>
                </div>
            </div>
        </div>

        <!-- Área de Visualización Principal (Resultante) -->
        <div>
            <div class="flex justify-between items-end px-2 mb-1">
                 <h3 class="text-xs font-semibold text-slate-400 uppercase tracking-wider">Onda Estacionaria (Suma)</h3>
            </div>
            <div class="relative w-full aspect-[16/9] md:aspect-[2/1] bg-slate-900 rounded-xl shadow-2xl border border-slate-700 overflow-hidden">
                <canvas id="waveCanvas" class="w-full h-full block"></canvas>
                
                <!-- Etiquetas superpuestas -->
                <div class="absolute top-4 left-4 text-xs font-mono text-slate-500">x = 0</div>
                <div class="absolute top-4 right-4 text-xs font-mono text-slate-500">x = L</div>
                
                <!-- Leyenda visual -->
                <div class="absolute bottom-4 left-4 right-4 flex flex-wrap gap-4 text-xs text-slate-400 bg-slate-900/80 p-2 rounded border border-slate-700 pointer-events-none select-none justify-between md:justify-start">
                    <div class="flex items-center gap-2">
                        <span class="w-2 h-2 rounded-full bg-red-500 block"></span> Nodo
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="w-2 h-2 rounded-full bg-sky-400 block"></span> Resultante
                    </div>
                    <div class="flex items-center gap-2" id="analysisLegend" style="display: none;">
                        <span class="w-2 h-2 bg-yellow-400 block rotate-45"></span> |A|=h
                    </div>
                </div>
            </div>
        </div>

        <!-- Panel de Control e Información -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            
            <!-- Controles -->
            <div class="md:col-span-2 info-card rounded-xl p-6 space-y-6">
                
                <!-- Slider: Armónico (n) -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <label for="harmonic" class="font-semibold text-sky-300">Modo de Vibración (<span class="italic">n</span>)</label>
                        <span id="harmonicVal" class="bg-sky-500/20 text-sky-300 px-2 py-1 rounded font-mono font-bold">1</span>
                    </div>
                    <input type="range" id="harmonic" min="1" max="10" step="1" value="1">
                    <div class="flex justify-between text-xs text-slate-500 px-1">
                        <span>Fundamental</span>
                        <span>10º Armónico</span>
                    </div>
                </div>

                <!-- Grid secundario para Amplitud, Velocidad y Línea de Análisis -->
                <div class="grid grid-cols-2 gap-4">
                    <div class="space-y-2">
                        <label for="amplitude" class="text-sm font-medium text-slate-300">Amplitud Máxima</label>
                        <input type="range" id="amplitude" min="0" max="100" value="50">
                    </div>
                    <div class="space-y-2">
                        <label for="speed" class="text-sm font-medium text-slate-300">Velocidad Angular</label>
                        <input type="range" id="speed" min="0" max="100" value="30">
                    </div>
                </div>

                <!-- Sección Línea de Análisis (Ocultable) -->
                <div id="analysisControls" class="bg-slate-800/50 p-3 rounded-lg border border-yellow-500/20 hidden transition-all">
                    <div class="space-y-2">
                        <div class="flex justify-between items-center">
                            <label for="lineHeight" class="text-sm font-medium text-yellow-400">Altura de Línea (h)</label>
                            <span class="text-xs text-yellow-500/80 italic">Busca puntos con amplitud h</span>
                        </div>
                        <input type="range" id="lineHeight" class="analysis-slider" min="0" max="100" value="30">
                    </div>
                </div>
                
                <!-- Botones de Acción -->
                <div class="pt-2 grid grid-cols-2 md:grid-cols-4 gap-2">
                    <button id="slowMoBtn" class="py-2 bg-slate-700 hover:bg-slate-600 text-white text-xs md:text-sm font-semibold rounded transition-all flex items-center justify-center gap-1 border border-slate-600">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span id="slowMoText">Lenta</span>
                    </button>
                    
                    <button id="analysisBtn" class="py-2 bg-slate-700 hover:bg-slate-600 text-white text-xs md:text-sm font-semibold rounded transition-all flex items-center justify-center gap-1 border border-slate-600">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                        Línea
                    </button>

                     <button id="componentsBtn" class="py-2 bg-slate-700 hover:bg-slate-600 text-white text-xs md:text-sm font-semibold rounded transition-all flex items-center justify-center gap-1 border border-slate-600">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
                        </svg>
                        Desglosar
                    </button>

                    <button id="toggleBtn" class="py-2 bg-sky-600 hover:bg-sky-500 text-white text-xs md:text-sm font-semibold rounded transition-colors flex items-center justify-center gap-1 shadow-lg shadow-sky-900/20">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span id="toggleText">Pausar</span>
                    </button>
                </div>
            </div>

            <!-- Panel de Datos Físicos -->
            <div class="info-card rounded-xl p-6 flex flex-col justify-center space-y-4">
                <h3 class="text-lg font-semibold text-white border-b border-slate-700 pb-2">Propiedades</h3>
                
                <div class="space-y-3 font-mono text-sm">
                    <div class="flex justify-between">
                        <span class="text-slate-400">Longitud de Onda (&lambda;):</span>
                        <span id="wavelengthDisplay" class="text-sky-300">2L</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-slate-400">Nodos (Total):</span>
                        <span id="nodesDisplay" class="text-sky-300">2</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-slate-400">Vientres:</span>
                        <span id="antinodesDisplay" class="text-sky-300">1</span>
                    </div>
                    <div class="mt-4 pt-4 border-t border-slate-700 text-xs text-slate-500 italic">
                        Ecuación: y(x,t) = A·sin(kx)·cos(&omega;t)
                    </div>
                </div>
            </div>

        </div>
    </main>

    <script>
        // Configuración y Variables de Estado
        const mainCanvas = document.getElementById('waveCanvas');
        const compCanvas = document.getElementById('componentsCanvas');
        const ctxMain = mainCanvas.getContext('2d');
        const ctxComp = compCanvas.getContext('2d');
        
        const controls = {
            harmonic: document.getElementById('harmonic'),
            amplitude: document.getElementById('amplitude'),
            speed: document.getElementById('speed'),
            lineHeight: document.getElementById('lineHeight'),
            toggle: document.getElementById('toggleBtn'),
            toggleText: document.getElementById('toggleText'),
            slowMo: document.getElementById('slowMoBtn'),
            slowMoText: document.getElementById('slowMoText'),
            analysisBtn: document.getElementById('analysisBtn'),
            analysisPanel: document.getElementById('analysisControls'),
            analysisLegend: document.getElementById('analysisLegend'),
            componentsBtn: document.getElementById('componentsBtn'),
            componentsContainer: document.getElementById('componentsContainer')
        };

        const displays = {
            harmonic: document.getElementById('harmonicVal'),
            wavelength: document.getElementById('wavelengthDisplay'),
            nodes: document.getElementById('nodesDisplay'),
            antinodes: document.getElementById('antinodesDisplay')
        };

        let state = {
            n: 1,           // Número de armónicos
            amp: 50,        // Amplitud base (0-100)
            lineH: 30,      // Altura de la línea de análisis
            speed: 30,      
            time: 0,
            isRunning: true,
            slowMotionLevel: 0, 
            showAnalysis: false,
            showComponents: false,
            width: 0,
            height: 0,
            compWidth: 0,
            compHeight: 0
        };

        // Redimensionar canvas
        function resizeCanvases() {
            // Main Canvas
            const mainContainer = mainCanvas.parentElement;
            mainCanvas.width = mainContainer.clientWidth;
            mainCanvas.height = mainContainer.clientHeight;
            state.width = mainCanvas.width;
            state.height = mainCanvas.height;

            // Components Canvas
            // Si está oculto, compContainer.clientWidth puede ser 0, así que usamos mainContainer como fallback
            const compContainer = compCanvas.parentElement;
            const containerWidth = compContainer.clientWidth || mainContainer.clientWidth;
            compCanvas.width = containerWidth;
            compCanvas.height = compContainer.clientHeight || 150; // Fallback height
            state.compWidth = compCanvas.width;
            state.compHeight = compCanvas.height;
        }

        // Función principal de dibujo
        function draw() {
            if (!state.isRunning && !state.showAnalysis && !state.showComponents) return;

            const { width, height, n, amp, lineH } = state;
            
            // Limpieza
            ctxMain.clearRect(0, 0, width, height);
            if(state.showComponents) {
                ctxComp.clearRect(0, 0, state.compWidth, state.compHeight);
            }

            const centerY = height / 2;
            const maxAmplitude = height * 0.4;
            const currentAmp = (amp / 100) * maxAmplitude;
            const analysisAmp = (lineH / 100) * maxAmplitude;

            // Gestión del tiempo compartido
            let speedFactor = state.speed;
            if (state.slowMotionLevel === 1) speedFactor *= 0.1;
            else if (state.slowMotionLevel === 2) speedFactor *= 0.01;
            
            const omega = 0.05 + (speedFactor / 1000) * n; 
            if (state.isRunning) state.time += omega;

            const temporalFactor = Math.cos(state.time);

            // --- 0. CALCULAR PUNTOS DE ANÁLISIS (ANALÍTICAMENTE) ---
            let analysisPoints = [];
            if (state.showAnalysis && currentAmp > 0) {
                const ratio = analysisAmp / currentAmp;
                if (ratio <= 1.0) {
                    const baseAngle = Math.asin(ratio);
                    for (let k = 0; k < n; k++) {
                        const theta1 = (k * Math.PI) + baseAngle;
                        const theta2 = ((k + 1) * Math.PI) - baseAngle;
                        
                        const x1 = (theta1 * width) / (n * Math.PI);
                        const x2 = (theta2 * width) / (n * Math.PI);
                        
                        const sign = (k % 2 === 0) ? 1 : -1;
                        
                        const y1 = centerY + (currentAmp * ratio * sign * temporalFactor);
                        analysisPoints.push({ x: x1, y: y1 });

                        if (Math.abs(x1 - x2) > 0.1) {
                            const y2 = centerY + (currentAmp * ratio * sign * temporalFactor);
                            analysisPoints.push({ x: x2, y: y2 });
                        }
                    }
                }
            }

            // --- 1. DIBUJAR EN EL CANVAS DE COMPONENTES (SUPERIOR) ---
            if (state.showComponents) {
                const compCenterY = state.compHeight / 2;
                const compAmp = (currentAmp * 0.5); 
                
                // Línea Guía
                ctxComp.beginPath();
                ctxComp.strokeStyle = '#334155';
                ctxComp.setLineDash([5, 5]);
                ctxComp.moveTo(0, compCenterY);
                ctxComp.lineTo(state.compWidth, compCenterY);
                ctxComp.stroke();
                ctxComp.setLineDash([]);

                // Onda Derecha (Verde)
                ctxComp.beginPath();
                ctxComp.strokeStyle = '#34d399'; // Emerald 400
                ctxComp.lineWidth = 2;
                for (let x = 0; x <= state.compWidth; x++) {
                    const normalizedX = x / state.compWidth;
                    const kx = n * Math.PI * normalizedX;
                    const wt = state.time;
                    const y = compCenterY + (compAmp * Math.sin(kx - wt));
                    if (x === 0) ctxComp.moveTo(x, y); else ctxComp.lineTo(x, y);
                }
                ctxComp.stroke();
                
                // --- INDICADOR DE LONGITUD DE ONDA (LAMBDA) ---
                if (n >= 2) {
                    ctxComp.beginPath();
                    ctxComp.strokeStyle = '#e2e8f0'; // White/Slate
                    ctxComp.fillStyle = '#e2e8f0';
                    ctxComp.lineWidth = 1;

                    // Encontramos crestas de la onda verde: sin(kx - wt) = 1
                    // Argumento = pi/2 + 2*pi*m
                    // x = (0.5 + time/pi + 2*m) * width / n
                    // Corrección: Normalizar el tiempo factor para que siempre busquemos en pantalla
                    const tf = 0.5 + (state.time / Math.PI);
                    
                    // Queremos x en [0, width].
                    // 0 <= (tf + 2m) * W/n <= W
                    // 0 <= tf + 2m <= n
                    // -tf <= 2m <= n - tf
                    // -tf/2 <= m <= (n - tf)/2
                    
                    const startM = Math.floor(-tf / 2) - 1; // Un poco antes
                    const endM = Math.ceil((n - tf) / 2) + 1; // Un poco después
                    
                    let crests = [];
                    for(let m = startM; m <= endM; m++) {
                         const x = (tf + 2*m) * (state.compWidth / n);
                         if (x >= 0 && x <= state.compWidth) {
                             crests.push(x);
                         }
                    }

                    // Si hay al menos dos crestas consecutivas visibles
                    if (crests.length >= 2) {
                        const x1 = crests[0];
                        const x2 = crests[1];
                        const yLevel = compCenterY - compAmp - 15; // Un poco por encima
                        
                        // Línea horizontal
                        ctxComp.moveTo(x1, yLevel);
                        ctxComp.lineTo(x2, yLevel);
                        ctxComp.stroke();
                        
                        // Flechas
                        const arrowSize = 4;
                        // Flecha izq
                        ctxComp.beginPath();
                        ctxComp.moveTo(x1 + arrowSize, yLevel - arrowSize);
                        ctxComp.lineTo(x1, yLevel);
                        ctxComp.lineTo(x1 + arrowSize, yLevel + arrowSize);
                        ctxComp.stroke();
                        // Flecha der
                        ctxComp.beginPath();
                        ctxComp.moveTo(x2 - arrowSize, yLevel - arrowSize);
                        ctxComp.lineTo(x2, yLevel);
                        ctxComp.lineTo(x2 - arrowSize, yLevel + arrowSize);
                        ctxComp.stroke();
                        
                        // Etiqueta
                        ctxComp.textAlign = 'center';
                        ctxComp.font = '12px Inter';
                        ctxComp.fillText('λ', (x1 + x2) / 2, yLevel - 5);
                        
                        // Líneas de referencia verticales (dashed)
                        ctxComp.setLineDash([2, 2]);
                        ctxComp.strokeStyle = 'rgba(226, 232, 240, 0.3)';
                        ctxComp.beginPath();
                        ctxComp.moveTo(x1, yLevel);
                        ctxComp.lineTo(x1, compCenterY - compAmp);
                        ctxComp.moveTo(x2, yLevel);
                        ctxComp.lineTo(x2, compCenterY - compAmp);
                        ctxComp.stroke();
                        ctxComp.setLineDash([]);
                    }
                }

                // Onda Izquierda (Naranja)
                ctxComp.beginPath();
                ctxComp.strokeStyle = '#fb923c'; // Orange 400
                ctxComp.lineWidth = 2;
                for (let x = 0; x <= state.compWidth; x++) {
                    const normalizedX = x / state.compWidth;
                    const kx = n * Math.PI * normalizedX;
                    const wt = state.time;
                    const y = compCenterY + (compAmp * Math.sin(kx + wt));
                    if (x === 0) ctxComp.moveTo(x, y); else ctxComp.lineTo(x, y);
                }
                ctxComp.stroke();
            }

            // --- 2. DIBUJAR EN EL CANVAS PRINCIPAL (INFERIOR) ---

            // Línea equilibrio
            ctxMain.beginPath();
            ctxMain.strokeStyle = '#334155';
            ctxMain.setLineDash([5, 5]);
            ctxMain.moveTo(0, centerY);
            ctxMain.lineTo(width, centerY);
            ctxMain.stroke();
            ctxMain.setLineDash([]);

            // Líneas de análisis (h)
            if (state.showAnalysis) {
                ctxMain.beginPath(); ctxMain.strokeStyle = '#facc15'; ctxMain.lineWidth = 1;
                ctxMain.moveTo(0, centerY - analysisAmp); ctxMain.lineTo(width, centerY - analysisAmp);
                ctxMain.stroke();
                
                ctxMain.beginPath(); ctxMain.strokeStyle = '#facc15'; ctxMain.globalAlpha = 0.3; 
                ctxMain.setLineDash([4, 4]);
                ctxMain.moveTo(0, centerY + analysisAmp); ctxMain.lineTo(width, centerY + analysisAmp);
                ctxMain.stroke(); ctxMain.setLineDash([]); ctxMain.globalAlpha = 1.0;

                ctxMain.fillStyle = '#facc15'; ctxMain.font = '10px monospace';
                ctxMain.fillText('y = h', 5, centerY - analysisAmp - 5);
                ctxMain.fillText('y = -h', 5, centerY + analysisAmp + 12);
            }

            // Onda Estacionaria
            ctxMain.beginPath();
            ctxMain.lineWidth = 3;

            // Opacidad de la onda azul: más baja SOLO si estamos analizando con la línea amarilla
            let waveAlpha = 1.0;
            if (state.showAnalysis) waveAlpha = 0.35; 
            
            const gradient = ctxMain.createLinearGradient(0, 0, width, 0);
            gradient.addColorStop(0, `rgba(56, 189, 248, ${waveAlpha})`);
            gradient.addColorStop(0.5, `rgba(129, 140, 248, ${waveAlpha})`);
            gradient.addColorStop(1, `rgba(56, 189, 248, ${waveAlpha})`);
            ctxMain.strokeStyle = gradient;

            for (let x = 0; x <= width; x++) {
                const normalizedX = x / width;
                const spatialFactor = Math.sin(n * Math.PI * normalizedX);
                const y = centerY + (currentAmp * spatialFactor * temporalFactor);

                if (x === 0) ctxMain.moveTo(x, y);
                else ctxMain.lineTo(x, y);
            }
            ctxMain.stroke();

            // Nodos
            ctxMain.fillStyle = '#ef4444';
            const oldAlpha = ctxMain.globalAlpha;
            ctxMain.globalAlpha = 1.0; 
            for (let i = 0; i <= n; i++) {
                const nodeX = (width * i) / n;
                ctxMain.beginPath();
                ctxMain.arc(nodeX, centerY, 4, 0, Math.PI * 2);
                ctxMain.fill();
            }
            ctxMain.globalAlpha = oldAlpha;

            // Puntos análisis
            if (state.showAnalysis) {
                ctxMain.beginPath();
                ctxMain.strokeStyle = 'rgba(250, 204, 21, 0.6)'; 
                ctxMain.lineWidth = 2;
                analysisPoints.forEach(p => {
                    ctxMain.moveTo(p.x, centerY - analysisAmp); 
                    ctxMain.lineTo(p.x, centerY + analysisAmp); 
                });
                ctxMain.stroke();

                ctxMain.fillStyle = '#facc15'; 
                analysisPoints.forEach(p => {
                    ctxMain.beginPath();
                    ctxMain.rect(p.x - 4, p.y - 4, 8, 8); 
                    ctxMain.fill();
                });
            }

            if (state.isRunning) requestAnimationFrame(draw);
        }

        // Actualizar UI y variables
        function updateState() {
            state.n = parseInt(controls.harmonic.value);
            state.amp = parseInt(controls.amplitude.value);
            state.speed = parseInt(controls.speed.value);
            state.lineH = parseInt(controls.lineHeight.value);

            displays.harmonic.innerText = state.n;
            
            if (state.n === 1) displays.wavelength.innerText = "2L";
            else if (state.n % 2 === 0) displays.wavelength.innerText = `L/${state.n/2}`; 
            else displays.wavelength.innerText = `2L/${state.n}`;

            displays.nodes.innerText = state.n + 1;
            displays.antinodes.innerText = state.n;

            if (!state.isRunning) draw();
        }

        // --- Event Listeners ---

        window.addEventListener('resize', () => {
            resizeCanvases();
            if (!state.isRunning) { state.isRunning = true; requestAnimationFrame(() => { draw(); state.isRunning = false; }); }
        });

        [controls.harmonic, controls.amplitude, controls.speed, controls.lineHeight].forEach(el => {
            el.addEventListener('input', updateState);
        });

        controls.toggle.addEventListener('click', () => {
            state.isRunning = !state.isRunning;
            controls.toggleText.innerText = state.isRunning ? "Pausar" : "Reanudar";
            
            if(!state.isRunning) {
                controls.toggle.classList.replace('bg-sky-600', 'bg-green-600');
                controls.toggle.classList.replace('hover:bg-sky-500', 'hover:bg-green-500');
            } else {
                controls.toggle.classList.replace('bg-green-600', 'bg-sky-600');
                controls.toggle.classList.replace('hover:bg-green-500', 'hover:bg-sky-500');
                draw();
            }
        });

        controls.slowMo.addEventListener('click', () => {
            state.slowMotionLevel = (state.slowMotionLevel + 1) % 3;
            
            const baseClasses = "py-2 text-white text-xs md:text-sm font-semibold rounded transition-all flex items-center justify-center gap-1 border";
            
            if (state.slowMotionLevel === 0) {
                controls.slowMoText.innerText = "Lenta";
                controls.slowMo.className = `${baseClasses} bg-slate-700 hover:bg-slate-600 border-slate-600`;
            } else if (state.slowMotionLevel === 1) {
                controls.slowMoText.innerText = "10%";
                controls.slowMo.className = `${baseClasses} bg-indigo-600 hover:bg-indigo-500 border-indigo-400 shadow-lg shadow-indigo-500/20`;
            } else {
                controls.slowMoText.innerText = "1%";
                controls.slowMo.className = `${baseClasses} bg-fuchsia-600 hover:bg-fuchsia-500 border-fuchsia-400 shadow-lg shadow-fuchsia-500/20`;
            }
        });

        controls.analysisBtn.addEventListener('click', () => {
            state.showAnalysis = !state.showAnalysis;

            if (state.showAnalysis) {
                controls.analysisBtn.classList.replace('bg-slate-700', 'bg-yellow-600');
                controls.analysisBtn.classList.replace('hover:bg-slate-600', 'hover:bg-yellow-500');
                controls.analysisBtn.classList.replace('border-slate-600', 'border-yellow-400');
                controls.analysisPanel.classList.remove('hidden');
                controls.analysisLegend.style.display = 'flex';
            } else {
                controls.analysisBtn.classList.replace('bg-yellow-600', 'bg-slate-700');
                controls.analysisBtn.classList.replace('hover:bg-yellow-500', 'hover:bg-slate-600');
                controls.analysisBtn.classList.replace('border-yellow-400', 'border-slate-600');
                controls.analysisPanel.classList.add('hidden');
                controls.analysisLegend.style.display = 'none';
            }
            if (!state.isRunning) {
                state.isRunning = true;
                requestAnimationFrame(() => {
                    draw();
                    state.isRunning = false;
                });
            }
        });

        controls.componentsBtn.addEventListener('click', () => {
            state.showComponents = !state.showComponents;
            
            if(state.showComponents) {
                controls.componentsBtn.classList.replace('bg-slate-700', 'bg-emerald-600');
                controls.componentsBtn.classList.replace('hover:bg-slate-600', 'hover:bg-emerald-500');
                controls.componentsBtn.classList.replace('border-slate-600', 'border-emerald-400');
                
                controls.componentsContainer.classList.remove('hidden');
                
                // Forzar resize inmediato después de mostrar
                setTimeout(() => {
                    resizeCanvases();
                    if(!state.isRunning) {
                        state.isRunning = true;
                        requestAnimationFrame(() => {
                            draw();
                            state.isRunning = false;
                        });
                    }
                }, 50);

            } else {
                controls.componentsBtn.classList.replace('bg-emerald-600', 'bg-slate-700');
                controls.componentsBtn.classList.replace('hover:bg-emerald-500', 'hover:bg-slate-600');
                controls.componentsBtn.classList.replace('border-emerald-400', 'border-slate-600');
                
                controls.componentsContainer.classList.add('hidden');
            }
        });

        // Inicialización
        resizeCanvases();
        updateState();
        draw();

    </script>
</body>
</html>
