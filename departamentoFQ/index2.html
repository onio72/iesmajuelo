
<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Asignación de tareas (cliente JS)</title>
<style>
  :root { --bg:#fff; --ink:#111; --muted:#6b7280; --accent:#2563eb; --line:#e5e7eb; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:var(--ink); background:var(--bg); margin:24px; }
  h1 { font-size: 1.25rem; margin: 0 0 12px; }
  .grid { display: grid; gap: 16px; grid-template-columns: 1fr 1fr; }
  textarea { width: 100%; height: 200px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 14px; padding: 8px; border:1px solid var(--line); border-radius: 8px; }
  .row { display:flex; gap:10px; align-items:center; margin-top:8px; }
  button { background:var(--accent); color:#fff; border:none; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600; }
  button:disabled { opacity: .5; cursor: not-allowed; }
  .note { color:var(--muted); font-size: .9rem; }
  .solutions { margin-top: 18px; }
  .card { border:1px solid var(--line); border-radius:12px; padding: 12px; margin-bottom: 14px; }
  table { width: 100%; border-collapse: collapse; margin-top: 8px; }
  th, td { border-bottom:1px solid var(--line); padding:6px 8px; text-align:left; font-size: 14px; }
  th { cursor: pointer; }
  .totals { display:flex; gap:10px; flex-wrap:wrap; margin-top:6px; font-size: 13px; }
  .pill { padding:4px 8px; border-radius:999px; background:#f1f5f9; border:1px solid var(--line); }
  details summary { cursor: pointer; }
  .kbd { font-family: ui-monospace, SFMono-Regular, monospace; background:#f3f4f6; border:1px solid #e5e7eb; padding:2px 6px; border-radius:6px; }

  /* Estilos para instrucciones y barras de resumen */
  .instructions { margin-bottom: 8px; color: var(--muted); font-size: .9rem; }
  .bar-container { display: flex; width: 100%; height: 20px; overflow: hidden; border-radius: 4px; }
  .bar-segment { display: flex; align-items: center; justify-content: center; font-size: 11px; color: #111; white-space: nowrap; padding: 0 2px; }
</style>
</head>
<body>
  <h1>Asignación de tareas indivisibles</h1>
  <p class="note">Introduce profesores y tareas, y pulsa <span class="kbd">Calcular asignaciones</span>. Se listarán hasta 50 soluciones factibles.</p>

  <div class="grid">
    <div>
      <h3>Profesores y horas totales</h3>
      <textarea id="peopleInput">Antonio, 18
Julia, 18
Rafa, 18
Miguel, 18</textarea>
      <p class="instructions"><strong>Profesores:</strong> introduce cada profesor en una línea con su carga máxima de horas en el formato <span class="kbd">Nombre, horas</span> (por ejemplo, <span class="kbd">Ana, 18</span>).</p>
    </div>

    <div>
      <h3>Tareas (nombre, horas, asignación obligatoria opcional)</h3>
      <textarea id="tasksInput">Jefatura, 3, Julia
2ºESO A +TUT, 5, Cualquiera
2ºESO B, 3, Cualquiera
2ºESO C, 3, Cualquiera
2ºESO D, 3, Cualquiera
3ºESO A +TUT, 5, Cualquiera
3ºESO B, 3, Cualquiera
3ºESO C, 3, Cualquiera
3ºESO D, 3, Cualquiera
3ºESO E, 3, Cualquiera
4ºESO A, 3, Cualquiera
4ºESO B, 3, Cualquiera
4ºESO C, 3, Cualquiera
1º BACH M A, 4, Cualquiera
1º BACH M B, 4, Cualquiera
1º BACH T A, 4, Cualquiera
2º BACH M FIS, 4, Cualquiera
2º BACH M QUIM, 4, Cualquiera
2º BACH T QUIM, 4, Cualquiera
FPB, 8, Cualquiera</textarea>
      <p class="instructions"><strong>Tareas:</strong> introduce cada tarea con su nombre y duración (<span class="kbd">Nombre, horas</span>). Si una tarea debe asignarse obligatoriamente a alguien, añade la persona tras otra coma (<span class="kbd">Nombre, horas, Persona</span>). Utiliza <span class="kbd">Cualquiera</span> para tareas sin asignación fija. Añade <span class="kbd">+TUT</span> al nombre para marcar una tutoría.</p>
    </div>
  </div>

  <div class="row">
    <button id="runBtn">Calcular asignaciones</button>
    <span class="note" id="status"></span>
  </div>

  <!-- Instrucciones generales sobre restricciones y funcionamiento -->
  <p class="instructions">
    <strong>Restricciones:</strong> las tareas se asignan de forma indivisible respetando las horas disponibles de cada profesor. Las tutorías (marcadas con <span class="kbd">+TUT</span>) son incompatibles con la Jefatura y cada profesor solo puede tener una tutoría. Si una tarea tiene un profesor asignado obligatoriamente, indícalo; de lo contrario utiliza <span class="kbd">Cualquiera</span>.
  </p>
  <p class="instructions">
    Haz clic en <span class="kbd">Calcular asignaciones</span> para obtener hasta 50 soluciones distintas. A continuación se mostrará un resumen de asignaciones y todas las soluciones encontradas.
  </p>

  <!-- Summary table will be inserted here -->
  <!-- Explicación del resumen de asignaciones -->
  <p class="instructions"><strong>Resumen de asignaciones:</strong> para cada tarea se muestra una barra con los colores de los profesores. La anchura de cada segmento es proporcional al porcentaje de soluciones en las que esa tarea se asigna a cada profesor. El nombre y el porcentaje aparecen en la barra.</p>
  <div class="solutions" id="summary"></div>
  <!-- Explicación de las soluciones -->
  <p class="instructions"><strong>Soluciones:</strong> se listan todas las asignaciones válidas. Cada tarjeta muestra la carga de horas por profesor y una tabla de tareas asignadas. Puedes ordenar la tabla haciendo clic en los encabezados. Las filas están coloreadas según el profesor asignado.</p>
  <div class="solutions" id="solutions"></div>

<script>
(function() {
  const $ = (sel) => document.querySelector(sel);

  // Paleta de colores pastel para diferenciar a los profesores en las tablas de soluciones.
  // Si hay más profesores que colores definidos, se ciclan los colores.
  const COLOR_PALETTE = [
    '#fef3c7', // amarillo pálido
    '#d1fae5', // verde menta suave
    '#fde2e4', // rosa claro
    '#dbeafe', // azul pastel
    '#e9d5ff', // lila claro
    '#fff7e6', // beige muy claro
    '#fce7f3'  // rosa malva
  ];

  function parsePeople(text) {
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const arr = [];
    for (const line of lines) {
      const [nameRaw, hoursRaw] = line.split(",").map(s => (s||"").trim());
      if (!nameRaw || !hoursRaw) continue;
      const hours = Number(hoursRaw);
      if (!Number.isFinite(hours)) continue;
      arr.push({ name: nameRaw, base: hours });
    }
    return arr;
  }

  function parseTasks(text) {
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const arr = [];
    for (const line of lines) {
      const parts = line.split(",").map(s => (s||"").trim());
      const name = parts[0];
      const hours = Number(parts[1]);
      const assigned = (parts[2] && parts[2].toLowerCase() !== "cualquiera") ? parts[2] : null;
      if (!name || !Number.isFinite(hours)) continue;
      const isTut = /\+TUT\b/i.test(name);
      const isChief = /\bJefatura\b/i.test(name);
      arr.push({ name, hours, assigned, isTut, isChief });
    }
    return arr;
  }

  function sum(arr, fn) { return arr.reduce((a,b)=>a+fn(b),0); }

  function combinations(items, k) {
    // simple k-combinations
    const res = [];
    const n = items.length;
    function rec(start, comb) {
      if (comb.length === k) { res.push(comb.slice()); return; }
      for (let i=start; i<n; i++) {
        comb.push(items[i]);
        rec(i+1, comb);
        comb.pop();
      }
    }
    if (k === 0) return [[]];
    if (k > 0 && k <= items.length) rec(0, []);
    return res;
  }

  function enumerateAssignments(people, tasks, limit=50) {
    // capacities base y exceso según suma de tareas
    const totalTasks = sum(tasks, t => t.hours);
    const baseTotal = sum(people, p => p.base);
    const excess = Math.max(0, totalTasks - baseTotal); // nº de personas que tendrán base+1
    if (excess > people.length) return []; // imposible

    // Preasignaciones obligatorias (si existen en entrada)
    const forcedTasks = tasks.filter(t => t.assigned);
    const freeTasks   = tasks.filter(t => !t.assigned);

    // construir todas las distribuciones de capacidad posible (quién tiene +1)
    const idx = people.map((_,i)=>i);
    const capsOptions = combinations(idx, excess).map(indices => {
      const caps = people.map(p => p.base);
      for (const i of indices) caps[i] = people[i].base + 1;
      return caps;
    });

    // preaplicar obligatorias y validar
    function applyForced(caps) {
      const cap = caps.slice();
      const tutOwner = {}; // quién tiene una TUT
      const jefOwner = {}; // quién tiene una Jefatura
      const assign = {};
      for (const t of forcedTasks) {
        const i = people.findIndex(p => p.name.toLowerCase() === t.assigned.toLowerCase());
        if (i < 0) return null; // asignado no existe
        if (cap[i] < t.hours) return null;
        // incompatibilidad entre Jefatura y tutoría
        if (t.isChief && tutOwner[i]) return null;
        if (t.isTut && jefOwner[i]) return null;
        if (t.isTut) {
          if (tutOwner[i]) return null; // ya tenía una TUT
          tutOwner[i] = true;
        }
        if (t.isChief) {
          jefOwner[i] = true;
        }
        cap[i] -= t.hours;
        assign[t.name] = people[i].name;
      }
      return { cap, tutOwner, jefOwner, assign };
    }

    // ordenamos tareas libres por horas desc y TUT primero (mejor poda)
    freeTasks.sort((a,b) => (b.hours - a.hours) || ((b.isTut?1:0) - (a.isTut?1:0)));

    const results = [];
    // conjunto de claves canónicas para eliminar soluciones idénticas bajo permutaciones
    const seenKeys = new Set();

    // genera una clave que agrupa tareas libres con características idénticas (horas, tutoría, jefatura)
    // e ignora su nombre concreto; ordena las personas asignadas dentro de cada grupo para evitar
    // considerar como diferentes aquellas soluciones que solo permutan tareas equivalentes.
    function canonicalKey(assign) {
      const groups = {};
      for (const t of tasks) {
        // solo consideramos tareas libres (sin asignación obligatoria)
        if (!t.assigned) {
          const gk = `${t.hours}-${t.isTut}-${t.isChief}`;
          if (!groups[gk]) groups[gk] = [];
          // persona asignada en esta solución para esta tarea
          const who = assign[t.name];
          groups[gk].push(who || "");
        }
      }
      const parts = [];
      const keys = Object.keys(groups).sort();
      for (const k of keys) {
        const arr = groups[k].slice().sort();
        parts.push(k + '=' + arr.join('|'));
      }
      return parts.join(';');
    }

    function backtrack(taskIdx, cap, tutOwner, jefOwner, assign, lastIdxMap) {
      if (results.length >= limit) return;
      if (taskIdx === freeTasks.length) {
        // todas asignadas → generar clave canónica y añadir solo si no existe
        const key = canonicalKey(assign);
        if (!seenKeys.has(key)) {
          seenKeys.add(key);
          results.push({ ...assign });
        }
        return;
      }
      const t = freeTasks[taskIdx];

      // poda: si la suma de cap < suma horas restantes -> imposible
      const remaining = freeTasks.slice(taskIdx).reduce((a,b)=>a+b.hours,0);
      const totalCap = cap.reduce((a,b)=>a+b,0);
      if (totalCap < remaining) return;

      // clave de grupo para tareas equivalentes (horas, tutoría, jefatura)
      const gkey = `${t.hours}-${t.isTut}-${t.isChief}`;
      const lastAssigned = lastIdxMap[gkey];

      for (let i=0; i<people.length; i++) {
        if (cap[i] < t.hours) continue;
        // no dos TUT en misma persona
        if (t.isTut && tutOwner[i]) continue;
        // incompatibilidad: no TUT si ya tiene Jefatura, ni viceversa
        if (t.isTut && jefOwner[i]) continue;
        if (t.isChief && tutOwner[i]) continue;
        // evitar permutaciones entre tareas equivalentes:
        // si ya se asignó una tarea de este grupo, solo permitir personas con índice >= último asignado
        if (lastAssigned !== undefined && i < lastAssigned) continue;
        // asignar
        cap[i] -= t.hours;
        const prevTut = tutOwner[i] || false;
        const prevChief = jefOwner[i] || false;
        if (t.isTut) tutOwner[i] = true;
        if (t.isChief) jefOwner[i] = true;
        assign[t.name] = people[i].name;
        const prevLast = lastIdxMap[gkey];
        lastIdxMap[gkey] = i;

        backtrack(taskIdx+1, cap, tutOwner, jefOwner, assign, lastIdxMap);

        // deshacer
        delete assign[t.name];
        if (t.isTut && !prevTut) delete tutOwner[i];
        if (t.isChief && !prevChief) delete jefOwner[i];
        cap[i] += t.hours;
        if (prevLast === undefined) delete lastIdxMap[gkey];
        else lastIdxMap[gkey] = prevLast;

        if (results.length >= limit) return;
      }
    }

    for (const caps of capsOptions) {
      const prep = applyForced(caps);
      if (!prep) continue;
      backtrack(0, prep.cap.slice(), { ...prep.tutOwner }, { ...prep.jefOwner }, { ...prep.assign }, {});
      if (results.length >= limit) break;
    }
    return results;
  }

  /**
   * Render a summary table showing, for cada tarea, el porcentaje de veces
   * que se asigna a cada profesor entre las soluciones proporcionadas.
   * Muestra el resultado ordenado de mayor a menor porcentaje para cada tarea.
   */
  function renderSummary(people, tasks, sols) {
    const summaryHost = $("#summary");
    summaryHost.innerHTML = "";
    // si no hay soluciones, no mostrar resumen
    if (!sols || sols.length === 0) {
      const d = document.createElement("div");
      d.className = "note";
      d.textContent = "No se han encontrado soluciones con los datos y restricciones actuales.";
      summaryHost.appendChild(d);
      return;
    }
    // contar asignaciones por tarea y profesor
    const counts = {};
    tasks.forEach(t => {
      counts[t.name] = {};
      people.forEach(p => {
        counts[t.name][p.name] = 0;
      });
    });
    sols.forEach(assign => {
      tasks.forEach(t => {
        const who = assign[t.name] || t.assigned;
        if (who && counts[t.name][who] != null) {
          counts[t.name][who]++;
        }
      });
    });
    const total = sols.length;
    const card = document.createElement("div");
    card.className = "card";
    const h = document.createElement("h3");
    h.textContent = "Resumen de asignaciones (%)";
    card.appendChild(h);
    const tbl = document.createElement("table");
    const thead = document.createElement("thead");
    const trh = document.createElement("tr");
    const thTask = document.createElement("th");
    thTask.textContent = "Tarea";
    trh.appendChild(thTask);
    const thAssign = document.createElement("th");
    thAssign.textContent = "Asignaciones";
    trh.appendChild(thAssign);
    thead.appendChild(trh);
    tbl.appendChild(thead);
    const tbody = document.createElement("tbody");
    // construir mapa de colores por profesor
    const colorMap = {};
    people.forEach(p => { colorMap[p.name] = p.color; });
    tasks.forEach(t => {
      const tr = document.createElement("tr");
      const tdName = document.createElement("td");
      tdName.textContent = t.name;
      tr.appendChild(tdName);
      const tdAssigns = document.createElement("td");
      // construir barra con segmentos proporcionales
      const bar = document.createElement("div");
      bar.className = "bar-container";
      // obtener porcentajes
      const arr = people.map(p => {
        return { name: p.name, pct: (counts[t.name][p.name] / total) * 100 };
      }).filter(a => a.pct > 0);
      // ordenar descendente para mostrar mayor primero
      arr.sort((a,b) => b.pct - a.pct);
      arr.forEach(a => {
        const seg = document.createElement("div");
        seg.className = "bar-segment";
        seg.style.backgroundColor = colorMap[a.name] || '#ddd';
        // usar flex proporcional al porcentaje
        seg.style.flex = a.pct.toFixed(4);
        seg.textContent = `${a.name} ${Math.round(a.pct)}%`;
        bar.appendChild(seg);
      });
      tdAssigns.appendChild(bar);
      tr.appendChild(tdAssigns);
      tbody.appendChild(tr);
    });
    tbl.appendChild(tbody);
    card.appendChild(tbl);
    summaryHost.appendChild(card);
  }

  function renderSolutions(people, tasks, sols) {
    const host = $("#solutions");
    host.innerHTML = "";

    const note = document.createElement("div");
    note.className = "note";
    const totalTasks = sum(tasks, t=>t.hours);
    const totalBase = sum(people, p=>p.base);
    const excess = Math.max(0, totalTasks - totalBase);
    note.textContent = `Encontradas ${sols.length} soluciones. Carga total: ${totalTasks} h. Capacidad base: ${totalBase} h. Exceso distribuido: ${excess} h.`;
    host.appendChild(note);

    sols.forEach((assign, idx) => {
      const card = document.createElement("div");
      card.className = "card";
      const h = document.createElement("h3");
      h.textContent = `Solución ${idx+1}`;
      card.appendChild(h);

      // totales por persona
      const hoursBy = Object.fromEntries(people.map(p=>[p.name,0]));
      tasks.forEach(t => {
        const who = assign[t.name] || t.assigned; // por si fue forzada
        if (who) hoursBy[who] = (hoursBy[who] || 0) + t.hours;
      });
      const totals = document.createElement("div");
      totals.className = "totals";
      for (const p of people) {
        const pill = document.createElement("span");
        pill.className = "pill";
        pill.textContent = `${p.name}: ${hoursBy[p.name] || 0} h`;
        totals.appendChild(pill);
      }
      card.appendChild(totals);

      // tabla de asignaciones con capacidad de ordenación
      const tbl = document.createElement("table");
      const thead = document.createElement("thead");
      const trh = document.createElement("tr");
      const thTarea = document.createElement("th");
      thTarea.textContent = "Tarea";
      thTarea.dataset.key = "task";
      const thPerson = document.createElement("th");
      thPerson.textContent = "Asignado a";
      thPerson.dataset.key = "person";
      const thHours = document.createElement("th");
      thHours.textContent = "Horas";
      trh.appendChild(thTarea);
      trh.appendChild(thPerson);
      trh.appendChild(thHours);
      thead.appendChild(trh);
      tbl.appendChild(thead);
      const tbody = document.createElement("tbody");
      // construir un mapa nombre->color para aplicar colores a las filas
      const colorMap = {};
      people.forEach(p => { colorMap[p.name] = p.color; });
      tasks.forEach(t => {
        const row = document.createElement("tr");
        const tdTask = document.createElement("td");
        tdTask.textContent = t.name;
        row.appendChild(tdTask);
        const tdAssign = document.createElement("td");
        const who = assign[t.name] || t.assigned || "—";
        tdAssign.textContent = who;
        row.appendChild(tdAssign);
        const tdH = document.createElement("td");
        tdH.textContent = t.hours;
        row.appendChild(tdH);
        // si hay profesor asignado y tiene color, colorear toda la fila de forma sutil
        if (who && colorMap[who]) {
          row.style.backgroundColor = colorMap[who];
        }
        tbody.appendChild(row);
      });
      tbl.appendChild(tbody);

      // función para ordenar filas según columna
      function sortTable(tbody, colIndex, order) {
        const rowsArray = Array.from(tbody.querySelectorAll("tr"));
        rowsArray.sort((a,b) => {
          const aText = a.children[colIndex].textContent.toLowerCase();
          const bText = b.children[colIndex].textContent.toLowerCase();
          if (aText < bText) return order === 'asc' ? -1 : 1;
          if (aText > bText) return order === 'asc' ? 1 : -1;
          return 0;
        });
        rowsArray.forEach(r => tbody.appendChild(r));
      }
      // manejador de clic para cabeceras
      thTarea.addEventListener('click', function() {
        const current = this.dataset.order || 'asc';
        const newOrder = current === 'asc' ? 'desc' : 'asc';
        this.dataset.order = newOrder;
        thPerson.dataset.order = '';
        sortTable(tbody, 0, newOrder);
      });
      thPerson.addEventListener('click', function() {
        const current = this.dataset.order || 'asc';
        const newOrder = current === 'asc' ? 'desc' : 'asc';
        this.dataset.order = newOrder;
        thTarea.dataset.order = '';
        sortTable(tbody, 1, newOrder);
      });

      card.appendChild(tbl);
      host.appendChild(card);
    });

    if (sols.length === 0) {
      const d = document.createElement("div");
      d.className = "note";
      d.textContent = "No se han encontrado soluciones con los datos y restricciones actuales.";
      host.appendChild(d);
    }
  }

  $("#runBtn").addEventListener("click", () => {
    const people = parsePeople($("#peopleInput").value);
    // asignar un color pastel a cada profesor para mejorar la lectura de las soluciones
    people.forEach((p, idx) => {
      p.color = COLOR_PALETTE[idx % COLOR_PALETTE.length];
    });
    const tasks  = parseTasks($("#tasksInput").value);
    const st = $("#status");
    st.textContent = "Calculando...";
    setTimeout(() => {
      const sols = enumerateAssignments(people, tasks, 50);
      // render resumen antes de soluciones
      renderSummary(people, tasks, sols);
      renderSolutions(people, tasks, sols);
      st.textContent = "Listo.";
    }, 10);
  });
})();
</script>
</body>
</html>
